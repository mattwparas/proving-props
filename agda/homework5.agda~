module _ where

open import list
open import eq
open import bool

{-

Prove that if there is a `ff` in a list, i.e., if you know this:

   list-member _iff_ ff l â‰¡ tt

for an arbitrary (l : ğ•ƒ ğ”¹), then list-and of that list is ff, i.e.:

   list-and l â‰¡ ff

The definition of list-member is in list.agda.

-}

falsemeansfalse : âˆ€ (l : ğ•ƒ ğ”¹) -> list-member _iff_ ff l â‰¡ tt  -> list-and l â‰¡ ff
falsemeansfalse [] ()
falsemeansfalse (tt :: l) listmember rewrite falsemeansfalse l listmember = refl
falsemeansfalse (ff :: l) listmember = refl

{-

Prove a similar result for list-or, namely that if there is a tt in
the input list, then list-or returns tt.

-}

truemeanstrue : âˆ€ (l : ğ•ƒ ğ”¹) -> list-member _iff_ tt l â‰¡ tt  -> list-or l â‰¡ tt
truemeanstrue [] ()
truemeanstrue (tt :: l) listmember = refl
truemeanstrue (ff :: l) listmember rewrite truemeanstrue l listmember = refl

{- prove that reversing a list twice returns the same list, i.e.

rev2x : âˆ€{â„“}{A : Set â„“} â†’ (l : ğ•ƒ A) -> reverse (reverse l) â‰¡ l

HINT: prove two lemmas, one that says what happens when
reverse-helper's first argument end with the list element `x` and one
that says what happens when the second argument ends with the list
element `x`. Here is the statement for the first one of those: 

rh-firstarg : âˆ€{â„“}{A : Set â„“} â†’ (x : A) -> (l m : ğ•ƒ A) -> 
  reverse-helper (l ++ (x :: [])) m â‰¡ (reverse-helper l m) ++ (x :: [])

These will be useful for finishing the inductive case in rev2x.

-}

rh-firstarg : âˆ€{â„“}{A : Set â„“} â†’ (x : A) -> (l m : ğ•ƒ A) -> 
  reverse-helper (l ++ (x :: [])) m â‰¡ (reverse-helper l m) ++ (x :: [])
rh-firstarg x [] [] = refl
rh-firstarg x [] (x1 :: m) = rh-firstarg x (x1 :: []) m
rh-firstarg x (x1 :: l) [] = refl
rh-firstarg x (x1 :: l) (x2 :: m) = rh-firstarg x (x2 :: x1 :: l) m


{- this is gonna change though -}


rh-secondarg : âˆ€{â„“}{A : Set â„“} â†’ (x : A) -> (l m : ğ•ƒ A) -> 
  reverse-helper l (m ++ (x :: [])) â‰¡ (x :: []) ++ (reverse-helper l m)
rh-secondarg x [] [] = refl
rh-secondarg x [] (x1 :: m) = rh-secondarg x (x1 :: []) m
rh-secondarg x (x1 :: l) [] = refl
rh-secondarg x (x1 :: l) (x2 :: m) = rh-secondarg x (x2 :: x1 :: l) m


rev2x : âˆ€{â„“}{A : Set â„“} â†’ (l : ğ•ƒ A) -> reverse (reverse l) â‰¡ l
rev2x [] = refl
rev2x (x :: l)
  rewrite rh-firstarg x [] l
  | rh-secondarg x [] (reverse-helper [] l )
  | rev2x l = refl
